function [neuronn, tree, testoutput] = poiraziCh(inputtree, morphopath)
%% Description
% Input: poiraziCh(<treecell>, <outputpath>)
% Output: [neuronn, tree]
%
% poiraziCh() is a function to add mechanisms from Poirazi et al. 2003 to any
% inputtree morphology from path morphopath.
% 
% Script from Laura Mediavilla 2020, greatly improved by Adrian Röth 

%% Start
% Fast inactivating potassium current
insertka = true;
% L-type calcium channel with high treshold of activation
% L-type current is distributed in a maximum fixed conductance for
% distances xdist > 50 um and in a very small conductance for xdist
% < 50 um
insertcalH = true;

%% Loop over all input structs in a cell

for cell = 1:length(inputtree)
    tree = inputtree{cell}
    
    %% set tree.rnames Region Names 
    for ctr = 1:length(tree.rnames)    
        if strcmp(tree.rnames{ctr},'Apical')
            Apind = ctr;
            tree.rnames{ctr} = 'apical';
        elseif strcmp(tree.rnames{ctr},'Dendrite')
            Baind = ctr;
            tree.rnames{ctr} = 'basal';
        elseif strcmp(tree.rnames{ctr},'CellBody')
            Soind = ctr;
            tree.rnames{ctr} = 'soma';
        elseif strcmp(tree.rnames{ctr},'Axon')
            Axind = ctr;
            tree.rnames{ctr} = 'axon';
        elseif strcmp(tree.rnames{ctr},'MainApical')
            MApind = ctr;
            MainAp = find(tree.R == MApind);
        end
    end

    if exist('Apind') & exist('MApind')
        tree.R(MainAp) = Apind;
    end

    OrBaNodes = find(tree.R == Baind);
    tree = CA1pyramidalcell_sort_PP(tree,'-p',1);
        tree.R(OrBaNodes) = 2;
        % % figure; hold on;
        % % plot_tree(tree,tree.R)
        % % soNoodes = find(tree.R == 1);
        % % baNoodes = find(tree.R == 2);
        % % trNoodes = find(tree.R == 3);
        % % ptNoodes = find(tree.R == 4);
        % % apNoodes = find(tree.R == 5);
        % % scatter3(tree.X(soNoodes),tree.Y(soNoodes),...
        % %     tree.Z(soNoodes),'filled','g');
        % % scatter3(tree.X(baNoodes),tree.Y(baNoodes),...
        % %     tree.Z(baNoodes),'filled','r');
        % % scatter3(tree.X(trNoodes),tree.Y(trNoodes),...
        % %     tree.Z(trNoodes),'filled','k');
        % % scatter3(tree.X(ptNoodes),tree.Y(ptNoodes),...
        % %     tree.Z(ptNoodes),'filled','b');
        % % scatter3(tree.X(apNoodes),tree.Y(apNoodes),...
        % %     tree.Z(apNoodes),'filled','y');

        % NrRegions = length(tree.rnames);
        % if ~exist('Axind')
        %     tree.rnames{NrRegions+1} = 'axon';
        %     tree.rnames{NrRegions+2} = 'trunk';
        %     tree.rnames{NrRegions+3} = 'peritrunk';
        % else
        %     tree.rnames{NrRegions+1} = 'trunk';
        %     tree.rnames{NrRegions+2} = 'peritrunk';
        % end
        % % tree.rnames = {'apical','soma','basal','axon','trunk','peritrunk'};
        % apnodes = find(tree.R == Apind);
        % trunknodes = find(tree.X(apnodes) <= 50);
        % if ~isempty(trunknodes)
        %     tree.R(apnodes(trunknodes)) = 5;
        % end
        % peritrunknodes = find(tree.X(apnodes) > 50 & tree.X(apnodes) <= 300);
        % if ~isempty(peritrunknodes)
        %     tree.R(apnodes(peritrunknodes)) = 6;
        % end
        % % plot_tree(tree,tree.R);


    tname = tree.name;
    treepath = morphopath;
    tree = t2n_writeTrees (tree, tname,...
                              fullfile (treepath, 'experiment.mtr'));
    %fname = tree.name;
    %tree = t2n_writeTrees(tree, [], fullfile (morphopath, strcat(fname,'_', t, '.mtr')));

       % tree = t2n_writeTrees(tree, fname, fullfile (morphopath, strcat(fname,'_', t, '.mtr')));
    % end
    %% Simulation Parameters

    tstop                    = 2100;
    dt                       = 0.05;
    neuron.params            = [];
    neuron.params.celsius    = 34;
    neuron.params.v_init     = -70;
    neuron.params.prerun     = 200;
    neuron.params.tstop      = tstop;
    neuron.params.dt         = dt;
    neuron.params.nseg       = 'Each 75';
    neuron.experiment        = 'out';

    %% Add Passive Parameters

    Cm_default               = 1;         % Membrane capacitance (?F/cm?)
    v_init                   = -70;       % in mV; Initial voltage of the sections
    e_pas                    = v_init;
    Rm_default               = 200000;    % in ohmcm? -> 200 Kohmcm? Poirazi et al. 2003
    Rm_end                   = 12000;     % in ohmcm? -> 12 Kohmcm? Poirazi et al. 2003
    Rm_dhalf                 = 200;       % in um
    Rm_steep                 = 50;        % in um
    Ri_default               = 50;        % in ohmcm?
    Ri_end                   = 35;        % in ohmcm?
    Ri_dhalf                 = 210;       % in um
    Ri_steep                 = 50;        % in um


    %% Calculations needed to set the Parameters
    % (specific from Poirazi's model)

    [basalnode, apicalnode] = calculate_basalapicalnode(tree);

    [trunk_branchpoints, peritrunk_branch] = find_peritrunknodes(tree);

    [idnodes300, idnodes350] = getdistalnodesPP(tree);

    treenodes = (1:numel(tree.X))';


    % Scaling the original sigmoid from Poirazi's model:
    Rm_sigmoid        = getPPsigmoid (tree, Rm_default, Rm_end, Rm_dhalf, Rm_steep);
    Ri_sigmoid       = getPPsigmoid (tree, Ri_default, Ri_end, Ri_dhalf, Ri_steep);

    % Adding to the sigmoid the value of the peritrunk area. The Ra does not include the peritrunk area
    Rm_sigmoid_p      = addPeritrunkval (treenodes, trunk_branchpoints, peritrunk_branch, Rm_sigmoid);


    neuron.mech.range.pas        = struct ( ...
        'g',                   1./ Rm_sigmoid_p);
    neuron.mech.trunk.pas        = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_default, ...
        'e',                   e_pas);
    neuron.mech.peritrunk.pas    = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_default, ...
        'e',                   e_pas);
    neuron.mech.soma.pas         = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_default, ...
        'e',                   e_pas);
    neuron.mech.basal.pas        = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_sigmoid_p(basalnode), ...
        'e',                   e_pas);
    neuron.mech.apical.pas       = struct ( ...
        'cm',                  Cm_default, ...
        'Ra',                  Ri_default, ...
        'g',                   1 / Rm_sigmoid_p(apicalnode), ...
        'e',                   e_pas);

    % this part is for the axon
    neuron.mech.hill.pas     = struct ( ...
        'cm',              Cm_default, ...
        'Ra',              Ri_default, ...
        'g',               1 / Rm_default, ...
        'e',               e_pas);
    neuron.mech.iseg.pas     = struct ( ...
        'cm',              Cm_default, ...
        'Ra',              Ri_default, ...
        'g',               1 / Rm_default, ...
        'e',               e_pas);
    neuron.mech.node.pas     = struct ( ...
        'cm',              Cm_default, ...
        'Ra',              Ri_default, ...
        'g',               1 / Rm_default, ...
        'e',               e_pas);
    neuron.mech.myelin.pas   = struct ( ...
        'cm',              Cm_default, ...
        'Ra',              Ri_default, ...
        'g',               1 / Rm_default, ...
        'e',               e_pas);


    %% Add active mechanisms

    % Voltage-dependent Na+ current and delayed rectifier
    gna_default      = 0.007;    % in mho(S)/cm2
    gna_axon         = 0.1;      % in mho(S)/cm2
    trunk_non_trunk_ratio = 1.0;
    % Delayed rectifier properties as percentage of Na conductance
    kdr_div          = 10.0 / 1.24;
    kdr_div_soma     = 10.0 / 2.0;
    % Delayed rectifier conductances
    gkdrbar_default  = gna_default / kdr_div;
    gkdrbar_soma     = gna_default / kdr_div_soma;
    gkdrbar_axon     = gna_axon    / kdr_div_soma;
    % Activity dependent attenuation calculation (ar2 parameter):0 is
    % maximum attenuation, 1 is no attenuation. Along the apical trunk
    min_ar2          = 0.30;
    max_ar2          = 0.95;
    decay_start      = 50;
    decay_end        = 300;
    %---------------------
    ar2_hha_old_linear   = getPPar2        (tree, ...
    min_ar2, max_ar2, decay_start, decay_end);
    % ar2_hha_old_linear = 1;

    % Adding to the sigmoid the value of the peritrunk area:
    ar2_hha_old_linear_p = addPeritrunkval (treenodes, ...
    trunk_branchpoints, ...
    peritrunk_branch, ...
    ar2_hha_old_linear);
    % ar2_hha_old_linear_p = 1;

    % Apical value of conductances: for distances > 350um
    for node         = 1 : numel (ar2_hha_old_linear_p)
        if sum (ismember (idnodes350, node)) == 1
            % change the more distal apical nodes values. The lss
            % distal apical nodes, take the value of the apical
            % dendrite 46:
            ar2_hha_old_linear_p (node, 1) = 0.95;
            gkdrbar_hha_old (node, 1) = 1.07 * gkdrbar_default;
        else
            gkdrbar_hha_old (node, 1) = NaN;
        end
    end
    % gkdrbar_hha_old = 1;
    %---------------------

    % trunk, peritrunk and apical (distances more than 350um) nodes are
    % included in the range variable. Only distal apical in th case of
    % kdr channel:
    neuron.mech.range.hha_old        = struct ( ...
        'gkbar',           gkdrbar_hha_old, ...
        'ar2',             ar2_hha_old_linear_p);
    neuron.mech.trunk.hha_old        = struct ( ...
        'gnabar',          gna_default, ...
        'gkbar',           gkdrbar_default, ...
        'ar2',             1, ...
        'gl',              0, ...
        'el',              v_init, ...
        'ena',             50, ...
        'ek',              -77);
    neuron.mech.peritrunk.hha_old    = struct ( ...
        'gnabar',          gna_default, ...
        'gkbar',           gkdrbar_default, ...
        'ar2',             1, ...
        'gl',              0, ...
        'el',              v_init, ...
        'ena',             50, ...
        'ek',              -77);
    neuron.mech.apical.hha_old       = struct ( ...
        'gnabar',          trunk_non_trunk_ratio*gna_default, ...
        'gkbar',           gkdrbar_default, ...
        'ar2',             0.8*ar2_hha_old_linear_p(apicalnode), ...
        'gl',              0, ...
        'el',              v_init, ...
        'ena',             50, ...
        'ek',              -77);    % set to 80% of the dend.46 value
    neuron.mech.basal.hha_old        = struct ( ...
        'gnabar',          gna_default, ...
        'gkbar',           gkdrbar_default, ...
        'ar2',             1, ...
        'W',               0.016, ...
        'gl',              0, ...
        'el',              v_init, ...
        'ena',             50, ...
        'ek',              -77);
    neuron.mech.soma.hha2            = struct ( ...
        'gnabar',          gna_default, ...
        'gkbar',           gkdrbar_soma, ...
        'ar2',             1, ...
        'W',               0.016, ...
        'gl',              0, ...
        'el',              v_init, ...
        'ena',             50, ...
        'ek',              -77);

    %  Hyperpolarization activated current (uses Na+ ions) 
    gh_default       = 1.872e-5;   % in mho/cm2
    gh_end           = gh_default * 9;
    gh_dhalf         = 280;
    gh_steep         = 50;
    K                = 8.8;

    % Sigmoidally decreasing H-current distribution: along apical trunk.
    h_sigmoid     = getPPsigmoid    (tree, ...
    gh_default, gh_end, gh_dhalf, gh_steep);
    % h_sigmoid = 1;

    % Peritrunk values of conductances: value from each branch node in
    % the trunk -> for distances close to the parent trunk section keep
    % trunk values:
    h_sigmoid_p   = addPeritrunkval (treenodes, ...
    trunk_branchpoints, peritrunk_branch, h_sigmoid);
    % h_sigmoid_p = 1;

    % trunk a peritrunk nodes are included in the range variable:
    neuron.mech.range.h              = struct ( ...
        'gbar',            h_sigmoid_p);
    neuron.mech.trunk.h              = struct ( ...
        'gbar',            gh_default, ...
        'eh',              -10, ...
        'ena',             50);
    neuron.mech.peritrunk.h          = struct ( ...
        'gbar',            gh_default, ...
        'eh',              -10, ...
        'ena',             50);
    neuron.mech.apical.h             = struct ( ...
        'gbar',            h_sigmoid_p(apicalnode), ...
        'eh',              -10, ...
        'ena',             50);
    neuron.mech.soma.h               = struct ( ...
        'gbar',            gh_default, ...
        'K',               K, ...
        'vhalf',           -82, ...
        'eh',              -10, ...
        'ena',             50);
    % does not get the value of the apical dendrite 14:
    neuron.mech.basal.h              = struct ( ...
        'gbar',            gh_default, ...
        'eh',              -10, ...
        'ena',             50);


    % Fast inactivating potassium current
    if insertka
        soma_kap     = 0.0075;              % in mho(S)/cm2
        kad_init     = 1.04 * 0.0072;         % in mho(S)/cm2
        kap_distal_distance  = 100;      % in um
        kad_distal_maxfactor = 6.5;
        kad_distal_distance  = 350;      % in um

        % Distribution function: only for the apical trunk
        [gkabar_kap_fixed, gkabar_kad_linear] = getPPka (tree, ...
            soma_kap,kad_init,   kap_distal_distance, ...
            kad_distal_distance, kad_distal_maxfactor);
    %     gkabar_kap_fixed    = 1;
    %     gkabar_kad_linear   = 1;

        % Peritrunk values of conductances: value from each branch node
        % in the trunk -> for distances close to the parent trunk
        % section keep trunk values:
        gkabar_kap_fixed_p   = addPeritrunkval (treenodes, ...
            trunk_branchpoints, peritrunk_branch, gkabar_kap_fixed);
        gkabar_kad_linear_p  = addPeritrunkval (treenodes, ...
            trunk_branchpoints, peritrunk_branch, gkabar_kad_linear);
    %     gkabar_kap_fixed_p  = 1;
    %     gkabar_kad_linear_p = 1;

        % Apical value of conductances: for distances > 300um for Kad
        for node     = 1 : numel (gkabar_kad_linear_p)
            if sum   (ismember (idnodes300, node)) == 1
                % change the more distal apical nodes values. The lss
                % distal apical nodes, take the value of the apical
                % dendrite 46:
                gkabar_kad_linear_p(node, 1) = ...
                    gkabar_kad_linear_p(apicalnode) * 1.3 * 1.9;
            end
        end

        % includes the trunk, peritrunk and further than 300um apical nodes:
        neuron.mech.range.kap        = struct ('gkabar', gkabar_kap_fixed_p);
        neuron.mech.range.kad        = struct ('gkabar', gkabar_kad_linear_p);

        neuron.mech.trunk.kap        = struct ('gkabar', soma_kap, 'ek', -80);
        neuron.mech.trunk.kad        = struct ('gkabar', soma_kap, 'ek', -80);

        neuron.mech.peritrunk.kap    = struct ('gkabar', soma_kap, 'ek', -80);
        neuron.mech.peritrunk.kad    = struct ('gkabar', soma_kap,'ek', -80);

        neuron.mech.apical.kap       = struct ('gkabar', gkabar_kap_fixed_p(apicalnode), 'ek', -80); % this should be zero
        neuron.mech.apical.kad       = struct ('gkabar', gkabar_kad_linear_p(apicalnode) * 1.25, 'ek', -80);

        neuron.mech.soma.kap         = struct ('gkabar', soma_kap, 'ek', -80); % no kad in soma

        neuron.mech.basal.kap        = struct ('gkabar', gkabar_kap_fixed_p(basalnode) * 1.6, 'ek', -80);
        neuron.mech.basal.kad        = struct ('gkabar', gkabar_kap_fixed_p(basalnode) * 1.6, 'ek', -80);
    end


    % Slow, noninactivating m-type K+ current 
    % Fixed conductance along the apical trunk
    soma_km          = 0.06;     % mho(S)/cm2
    neuron.mech.soma.km              = struct ( ...
        'gbar',            soma_km, ...
        'ek',              -80);
    neuron.mech.trunk.km             = struct ( ...
        'gbar',            soma_km, ...
        'ek',              -80);
    neuron.mech.peritrunk.km         = struct ( ...
        'gbar',            soma_km, ...
        'ek',              -80);
    neuron.mech.apical.km            = struct ( ...
        'gbar',            soma_km * 2, ...
        'ek',              -80);

    % L-type calcium channel with low threshold for activation
    % Only in the soma
    soma_caL         = 0.014;    % mho(S)/cm2
    neuron.mech.soma.cal             = struct ( ...
        'gcalbar',         soma_caL / 2);  % only in the soma

    %  L-type calcium channel with high treshold of activation
    % L-type current is distributed in a maximum fixed conductance for
    % distances xdist > 50 um and in a very small conductance for xdist
    % < 50 um
    if insertcalH
        soma_caLH    = 0.95 * 0.000333;     % in mho/cm2

        % -----------------------
        gcalbar_calH   = getPPcalH       (tree, ...
            soma_caLH);
    %     gcalbar_calH = 1;

        % Peritrunk values of conductances: value from each branch node
        % in the trunk -> for distances close to the parent trunk
        % section keep trunk values:
        gcalbar_calH_p = addPeritrunkval (treenodes, ...
            trunk_branchpoints, peritrunk_branch, gcalbar_calH);
    %     gcalbar_calH_p = 1;

        % Apical value of conductances: for distances > 300um for Kad
        for node     = 1 : numel (gcalbar_calH_p)
            if sum   (ismember (idnodes300, node)) == 1
                % change the more distal apical nodes values. The
                % lss distal apical nodes, take the value of the
                % apical dendrite 46:
                gcalbar_calH_p (node, 1) = soma_caLH * 14;
            end
            if sum   (ismember (idnodes350, node)) == 1
                % change the more distal apical nodes values. The lss
                % distal apical nodes, take the value of the apical
                % dendrite 46:
                gcalbar_calH_p (node, 1) = soma_caLH * 15;
            end
        end
        % -----------------------

        % includes the trunk, peritrunk and further than 300-350um
        % apical nodes:
        neuron.mech.range.calH       = struct ( ...
            'gcalbar',     gcalbar_calH_p);
        neuron.mech.trunk.calH       = struct ( ...
            'gcalbar',     soma_caLH, ...
            'eca',         140);
        neuron.mech.peritrunk.calH   = struct ( ...
            'gcalbar',     soma_caLH, ...
            'eca',         140);
        neuron.mech.apical.calH      = struct ( ...
            'gcalbar',     soma_caLH, ...
            'eca',         140);
    end

    % T-type calcium channel with high threshold for activation
    % Inserting LVA Ca++ T-type channels along the apical trunk in a
    % linearly increasing manner, for xdist > 100 um:
    soma_caT         = 0.0001;  % mho(S)/cm2
    caT_distal_maxfactor = 4;
    caT_distal_distance  = 350;

    % ------------------
    gcatbar_cat       = getPPcat (tree, ...
    soma_caT, caT_distal_distance, caT_distal_maxfactor);
    % gcatbar_cat = 1;

    % Peritrunk values of conductances: value from each branch node in
    % the trunk -> for distances close to the parent trunk section keep
    % trunk values:
    gcatbar_cat_p     = addPeritrunkval (treenodes, ...
    trunk_branchpoints, ...
    peritrunk_branch, ...
    gcatbar_cat);
    % gcatbar_cat_p = 1;

    neuron.mech.range.cat            = struct ( ...
        'gcatbar',         gcatbar_cat_p);
    neuron.mech.trunk.cat            = struct ( ...
        'gcatbar',         soma_caT);
    neuron.mech.peritrunk.cat        = struct ( ...
        'gcatbar',         soma_caT);
    neuron.mech.apical.cat           = struct ( ...
        'gcatbar',         gcatbar_cat_p(apicalnode));
    neuron.mech.soma.cat             = struct ( ...
        'gcatbar',         soma_caT / 2);

    % Ca R-type channel with medium threshold for activation
    % Only in the soma
    gsomacar         = 0.003;   % mho(S)/cm2
    neuron.mech.soma.somacar         = struct ( ...
        'gcabar',          gsomacar, ...
        'eca',             140);
    % Only in the dendrites, and ranged in distal areas
    init_car         = 0.0003;   % in mho(S)/cm2
    trunk_car        = init_car * 0.1;

    % ------------------
    for node         = 1 : numel (treenodes)
        if sum       (ismember (idnodes300, node)) == 1
            % change the more distal apical nodes values. The lss
            % distal apical nodes, take the value of the apical
            % dendrite 46:
            gcabar_car (node, 1) = 13 * init_car;
        else
            gcabar_car (node, 1) = NaN;
        end
    end
    % gcabar_car = 1;

    neuron.mech.range.car            = struct ( ...
        'gcabar',          gcabar_car);  % Only apical included
    neuron.mech.apical.car           = struct ( ...
        'gcabar',          init_car, ...
        'eca',             140);
    neuron.mech.trunk.car            = struct ( ...
        'gcabar',          trunk_car, ...
        'eca',             140);
    neuron.mech.peritrunk.car        = struct ( ...
        'gcabar',          trunk_car, ...
        'eca',             140);

    % Slow (kca) and Medium (mykca) AHP Ca-dependent potassium current
    soma_kca         = 0.0001;  % mho/cm2
    soma_cagk        = 1.1 * 0.015;
    % distance in dendrites for maximum conductance:
    kca_distal_distance = 200;

    % -----------
    [gkbar_cagk, gbar_kca] = getPPkca(tree, ...
        soma_kca,soma_cagk, ...
        kca_distal_distance);
    % gkbar_cagk = 1;
    % gbar_kca = 1;

    % Peritrunk values of conductances: value from each branch node in
    % the trunk -> for distances close to the parent trunk section keep
    % trunk values:
    gkbar_cagk_p   = addPeritrunkval(treenodes, ...
        trunk_branchpoints, ...
        peritrunk_branch, ...
        gkbar_cagk);
    gbar_kca_p     = addPeritrunkval(treenodes, ...
        trunk_branchpoints, ...
        peritrunk_branch, ...
        gbar_kca);
    % gkbar_cagk_p = 1;
    % gbar_kca_p = 1;

    % Apical value of conductances: for distances > 300um
    for node         = 1 : numel (gbar_kca_p)
        if sum       (ismember (idnodes300, node)) == 1
            % change the more distal apical nodes values. The lss
            % distal apical nodes, take the value of the apical
            % dendrite 46:
            gbar_kca_p(node, 1)  = soma_kca * 5;
        end
    end

    % includes the trunk, peritrunk,and far apical:
    neuron.mech.range.kca        = struct ( ...
        'gbar',            gbar_kca_p);
    neuron.mech.trunk.kca        = struct ( ...
        'gbar',            soma_kca, ...
        'ek',              -80);
    neuron.mech.peritrunk.kca    = struct ( ...
        'gbar',            soma_kca, ...
        'ek',              -80);
    neuron.mech.apical.kca       = struct ( ...
        'gbar',            gbar_kca_p(apicalnode), ...
        'ek',              -80);
    neuron.mech.soma.kca         = struct ( ...
        'gbar',            5 * soma_kca, ...
        'ek',              -80);
    % includes the trunk, peritrunk:
    neuron.mech.range.mykca      = struct ( ...
        'gkbar',           gkbar_cagk_p);
    neuron.mech.trunk.mykca      = struct ( ...
        'gkbar',           soma_cagk, ...
        'ek',             -80);
    neuron.mech.peritrunk.mykca  = struct ( ...
        'gkbar',           soma_cagk, ...
        'ek',             -80);
    neuron.mech.apical.mykca     = struct ( ...
        'gkbar',           soma_cagk * 1.1, ...
        'ek',             -80);
    neuron.mech.soma.mykca       = struct ( ...
        'gkbar',           soma_cagk * 5.5, ...
        'ek',             -80);

    % Calcium buffering mechanism
    neuron.mech.soma.cad        = struct ( ...
        'depth',           0.1, ...
        'taur',            200, ...
        'cainf',           0.0001);
    neuron.mech.trunk.cad       = struct ( ...
        'depth',           0.1, ...
        'taur',            200, ...
        'cainf',           0.0001);
    neuron.mech.peritrunk.cad   = struct ( ...
        'depth',           0.1, ...
        'taur',            200, ...
        'cainf',           0.0001);
    neuron.mech.apical.cad      = struct ( ...
        'depth',           0.1, ...
        'taur',            200, ...
        'cainf',           0.0001);

    % Na+ persistent channel
    gna_default = 0.007;
    apdend_nap = 0.0004*gna_default;   % holding value of the apical dend 46
    trunk_nap = 0.2*apdend_nap;    % only a small percentage in the trunk


    % Apical value of conductances: for distances > 300um
    for node = 1:numel(treenodes)
        if sum(ismember(idnodes350, node)) == 1
            % change the more distal apical nodes values. The lss
            % distal apical nodes, take the value of the apical
            % dendrite 46:
            gbar_nap(node,1) = apdend_nap*2;
        else
            gbar_nap(node,1) = NaN;
        end
    end
    % gbar_nap = 1;

    %% Inserting the current: no included in basal, axon, trunk and soma
    neuron.mech.range.nap      = struct ( ...
        'gnabar',          gbar_nap);   % included apical region
    neuron.mech.peritrunk.nap  = struct ( ...
        'gnabar',          trunk_nap, ...
        'ena',             50);
    neuron.mech.apical.nap     = struct ( ...
        'gnabar',          apdend_nap, ...
        'ena',             50);

    %% INSERTING THE MECHANISMS IN THE AXON 
    neuron.mech.hill.hha2        = struct ( ...
        'gnabar',      gna_axon, ...
        'gkbar',       gkdrbar_axon, ...
        'ar2',         1, ...
        'W',           0.016, ...
        'gl',          0, ...
        'el',          v_init, ...
        'ena',         50, ...
        'ek',          -77);
    neuron.mech.iseg.hha2        = struct ( ...
        'gnabar',      gna_axon, ...
        'gkbar',       gkdrbar_axon, ...
        'ar2',         1, ...
        'W',           0.016, ...
        'gl',          0, ...
        'el',          v_init, ...
        'ena',         50, ...
        'ek',          -77);
    neuron.mech.node.hha2        = struct ( ...
        'gnabar',      gna_axon, ...
        'gkbar',       gkdrbar_axon, ...
        'ar2',         1, ...
        'W',           0.016, ...
        'gl',          0, ...
        'el',          v_init, ...
        'ena',         50, ...
        'ek',          -77);
    neuron.mech.myelin.hha2      = struct ( ...
        'gnabar',      gna_axon, ...
        'gkbar',       gkdrbar_axon, ...
        'ar2',         1, ...
        'W',           0.016, ...
        'gl',          0, ...
        'el',          v_init, ...
        'ena',         50, ...
        'ek',          -77);
    neuron.mech.hill.km          = struct ( ...
        'gbar',        0.5 * soma_km, ...
        'ek',          -80);
    neuron.mech.iseg.km          = struct ( ...
        'gbar',        0.5 * soma_km, ...
        'ek',          -80);
    neuron.mech.node.km          = struct ( ...
        'gbar',        0.5 * soma_km, ...
        'ek',          -80);
    neuron.mech.myelin.km        = struct ( ...
        'gbar',        0.5 * soma_km, ...
        'ek',          -80);

    %% DENDRITIC CONSTANCY EXP. POISSON ACTIVATION (subthresh)
                                                             % loop to run and safe simulation piece-wise % max n=length(tree)
    % for counter=1:length(tree)
    %     counter
    % cells                    = tree(counter);        % tree morphologies without the source stimulation cells
    % freq                     = 1;                                % frequency that lead to a subthreshold response using the subthreshold weigth
    % stimnum                  = 1e9;
    % syn_weight               = 0.00025;                          % weigth for the active model
    % with_nmda                = 0;                                % with NMDA synapses
    % cluster_syn              = 0;                                % clustered stimulation of apical subtree (10 syns)
    % syn_nmda                 = syn_weight * 1.08;                % nmda weights
    % inhib_syns               = 0;                                % with inhibitory syns
    % noise                    = 1;
    % syn_dens                 = 1;                                % Synapse per µm dendritic path length (all regions have same density)
    % N                        = 1;                                % Number of Simulations
    % regions                  = {'basal', 'trunk', 'peritrunk', 'apical'};   % Regions where synapses should be placed
    % for t                    = 1 : numel (cells)
    %     % array with as many zeros as nodes in the cells:
    %     dend{t}              = zeros (size (cells{t}.X), 'double');
    %     for sim              = 1 : numel (regions)
    %         % Get ones in the regions you want to activate:
    %         dend{t}          = dend{t} + double ( cells{t}.R (:) == find (strcmp (regions{sim}, cells{t}.rnames)));
    %     end
    %     % Get ones in the regions you do not want to activate:
    %     rest{t}              = double (abs (dend{t}-ones (size (cells{t}.X), 'double')));
    %     % Calculate the length of each group of regions in order to be able to
    %     % activate per density:
    %     dendlength (t)       = sum (len_tree (cells{t}).*dend{t});                    
    %     restlength (t)       = sum (len_tree (cells{t}).*rest{t});
    % end
    % nsyn_max                 = ceil (max (cellfun (@(x) sum (len_tree (x)), cells)-restlength') * max(syn_dens));  % Get the maximum number of synapses you will get with you conditions
    % % create as many artificial cells as synapses on the trees (take the tree with the maximum number of synapses)
    % cells (numel (cells) + 1 : numel (cells) + 1 + nsyn_max) = ...
    %     {(struct ( ...
    %     'artificial',          'NetStim', ...
    %     'start',               50, ...
    %     'interval',            1 / freq * 1000, ...
    %     'number',              stimnum, ...
    %     'noise',               noise, ...
    %     'seed',                '(1)'))};
    % 
    % thesesynids  = cell (numel (cells(1)), 1);
    % nsyn = cell (numel (cells(1)), 1);
    % for t = 1:numel (cells(1))
    %     neuronn{t} = neuron;
    %     neuronn{t}.mech             = neuron.mech(counter);
    %     %     iseg_nodes{t} = find(cells{t}.R == find(strcmp(cells{t}.rnames, 'iseg')));
    %     %     recnodes{t} = [1, iseg_nodes{t}(end)];   % measure at the end of the iseg region
    %     [~, i1]              = max (cells{t}.Y);
    %     recnodes             = [1 i1];
    %     neuronn{t}.record{t}.cell = struct('node',recnodes,'record',{'v'});
    %     %Synapse distribution
    %     if cluster_syn==0
    %         [nsyn{t}, thesesynids{t}, syndens{t}] = getsynnum (cells{t}, syn_dens, regions); % get the synaptic IDs
    %     else
    %         % Regions where subtree cluster should be placed
    %         apical_regions  = {'proxAp','middleAp','distalAp','tuft'};   
    %         apical_dend{t}  = zeros (size (cells{t}.X), 'double');
    %         for sim         = 1 : numel (apical_regions)
    %             apical_dend{t}  = apical_dend{t} + double ( cells{t}.R (:) == find (strcmp (apical_regions{sim}, cells{t}.rnames)));
    %         end
    %         %apical_dendlength(t) = sum (len_tree (cells{t}).*apical_dend{t});  
    %         total_length         = sum (len_tree (cells{t}));  
    %         % Percentage of apical tree to be activated
    %         activate_percent     = 0.2;
    %         cluster{t}    = apical_dend{t};
    %         % All branches
    %         [~,vec]       = dissect_tree(cells{t});        
    %         % Remove furthest branches until cluster in apical dendrites is as short as wanted
    %         while sum (len_tree (cells{t}).*cluster{t}) > activate_percent * total_length
    %             highest_branch_order = max(vec(:,1).*cluster{t});
    %             cluster{t} = cluster{t}.*(logical(vec(:,1)-highest_branch_order));
    %         end
    %         % Add last branch part that was removed too much
    %         error_len = round(activate_percent * total_length - sum (len_tree (cells{t}).*cluster{t}));
    %         if error_len>0
    %         last_branch = find(~logical(vec(:,1)-highest_branch_order),error_len);
    %         cluster{t}(last_branch) = 1;
    %         end
    %         thesesynids{t}=(1:numel(cells{t}.X))';
    %         thesesynids{t}=nonzeros(thesesynids{t}.*cluster{t});
    %         nsyn{t}=cluster{t};% since we take one syn per node anyway
    %     end
    %     nsyn_old{t}=nsyn{t};
    %     tags_ampa                   = string(compose('Tree%03d_synampa%d',t,1:numel(thesesynids{t})))';
    %     neuronn{t}.pp{t}.Exp2Syn(1) = struct ( ...
    %         'node',            thesesynids{t}, ...
    %         'tag',             tags_ampa, ...
    %         'tau1',            0.2, ...
    %         'tau2',            2.5, ...
    %         'e',               0);
    %     neuronn{t}.con(1 : numel(thesesynids{t})) = struct( ...
    %         'source',          struct ( ...
    %         'cell',            NaN, ...
    %         'watch',           'on'), ...
    %         'target',          struct ( ...
    %         'cell',            t, ...
    %         'pp',              'Exp2Syn', ...
    %         'node',            NaN), ...
    %         'weight',          syn_weight, ...
    %         'delay',           0, ...
    %         'threshold',       0.5);
    %     nneuron{t}.custom{t}       = [];
    %     for sim    = 1 : numel (thesesynids{t})
    %         neuronn{t}.con(sim).source.cell  = sim + numel (cells(1));     % the "n" artificial cell, is connected to
    %         neuronn{t}.con(sim).target.node  = thesesynids{t}(sim);     % the "n" synaptic node of the tree "t"
    %         % hack to come around the problem if more than one PP of the
    %         % same PP group is defined at the same node:
    %         neuronn{t}.con(sim).target.ipp   = nsyn_old {t}(thesesynids{t} (sim));
    %         nsyn_old{t} (thesesynids{t} (sim))  = nsyn_old{t} (thesesynids{t} (sim)) - 1;
    %     end
    %     
    % end
    % %%%% NMDA SYNAPSES
    % if with_nmda
    % for t = 1:numel(cells(1:n))
    %     prev_con_size{t} = size(neuronn{t}.con,2);
    % end
    % for t = 1:numel (cells(1:n))
    %     tags_nmda                   = string(compose('Tree%03d_synnmda%d',t,1:numel(thesesynids{t})))';
    %     nsyn_old{t}=nsyn{t};
    %     % NMDA SYNAPSE
    %     neuronn{t}.pp{t}.Exp2nmda2(1) = struct ( ...
    %         'node',            thesesynids{t}, ...
    %         'tag',             tags_nmda, ...
    %         'tau1',            0.33, ...
    %         'tau2',            50, ...
    %         'mg',              2, ...
    %         'eta',             0.05,...
    %         'gamma',           0.06, ...
    %         'gmax',            syn_nmda, ...
    %         'e',               0);
    %     neuronn{t}.con(prev_con_size{t}+1:prev_con_size{t}+numel(thesesynids{t})) = struct( ...
    %         'source',          struct ( ...
    %         'cell',            NaN, ...
    %         'watch',           'on'), ...
    %         'target',          struct ( ...
    %         'cell',            t, ...
    %         'pp',              'Exp2nmda2', ...
    %         'tag',             NaN), ...
    %         'weight',          syn_nmda, ...
    %         'delay',           0.05, ...
    %         'threshold',       0.5);
    %     % Connecting the artificial cell to the nodes where the synapses are placed: 
    %     for sim    = 1 : numel (thesesynids{t})  
    %         neuronn{t}.con(prev_con_size{t}+sim).source.cell  = sim + numel (cells(1:n));     % the "n" artificial cell, is connected to
    %         neuronn{t}.con(prev_con_size{t}+sim).target.tag  = tags_nmda (sim);      % the "n" synaptic node of the tree "t"
    %         % hack to come around the problem if more than one PP of the
    %         % same PP group is defined at the same node:
    %         neuronn{t}.con(prev_con_size{t}+sim).target.ipp   = nsyn_old {t}(thesesynids{t} (sim));
    %         nsyn_old{t} (thesesynids{t} (sim))   = nsyn_old{t} (thesesynids{t} (sim)) - 1;
    %     end
    % end
    % end
    % 
    % for counter3      = 1    % for every artificial cell, you set the interval and the seed
    %     tree{counter3}.interval = 1/freq*1000;
    % end
    % % Inhibitory syns with E= -65, 20% of all syns
    % if inhib_syns
    %     for t                = 1 : numel (cells(1))
    %     E = (rand (numel (thesesynids{t}), 1)>0.8) * (-65);
    %     neuronn{t}.pp{t}.Exp2Syn.e = E;
    %     end 
    % end
    % end

    %% Added to make it work (????)
    neuron.mech.soma.hha_old        = struct ( ...
        'gkbar',           gkdrbar_default, ...
        'ar2',             1);
    neuron.mech.soma.calH       = struct ( ...
        'gcalbar',     soma_caLH);
    neuron.mech.basal.calH       = struct ( ...
        'gcalbar',     soma_caLH);
    neuron.mech.basal.kca        = struct ( ...
        'gbar',            soma_kca);
    neuron.mech.basal.mykca        = struct ( ...
        'gbar',            soma_kca);
    neuron.mech.soma.kad        = struct ( ...
        'gkabar',      soma_kap);
    neuron.mech.basal.cat       = struct ( ...
        'gcatbar',         soma_caT);


    %%
    tempsave = neuron.mech;
    neuron = rmfield(neuron, 'mech');
    neuron.mech{1} = tempsave;

    % tempsave = neuronn{1}.mech;
    % neuronn{1} = rmfield(neuronn{1},'mech');
    % neuronn{1}.mech{1} = tempsave;



    neuron.record{1}.cell = struct('node', 1,'record', 'v');
    neuron.pp{1}.IClamp = struct('node', 1, 'times', [200 1800], 'amp', [0.2 0]);
    neuron.record{1}.IClamp = struct('node', 1, 'record', 'i');

    % neuronnSyn = neuronn;
    neuronn{1} = neuron;

    out = t2n(neuronn, tree, '-w-d');
    testoutput = tree
end

 


